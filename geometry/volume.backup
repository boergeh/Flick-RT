#ifndef optics_library_volume
#define optics_library_volume

#include "boundary.hpp"
#include <initializer_list>

namespace optics_library {
  //template <class Boundary, class... Args>
  class volume
  // A volume is confind by its boundary, and can have several other
  // volumes inside, which again can have volumes inside, forming a
  // tree structure
  {
    //Shape shape_{1};
    std::string name_;
    std::shared_ptr<boundary> boundary_;
    volume* outer_volume_; 
    std::vector<volume> inner_volumes_;
    //std::vector<std::shared_ptr<volume>> inner_volumes_;
    
    //vector closest_intersection_; // mutable?
    //const volume* closest_volume_;

    //friend std::ostream & operator<<(std::ostream &os, const volume& vol);
  protected:
    volume(std::shared_ptr<boundary> b_ptr, const std::string& name) : // make protected
      boundary_{b_ptr}, name_{name} {
    // mutable size_t n_volumes_outside_{0};

    //volume(Args... a) {
    //  boundary_ = std::make_shared<Boundary>(a...);
      //Shape shape(a...);
      //shape_ = shape;
      //boundary_ = shape_();
      //auto pp = std::make_shared<volume>()
      //inner_volumes_.push_back(t);
      
    //volume() {
      //std::cout << l.size() << std::endl;
    }
       
  public:

    /*
    volume(const std::shared_ptr<const boundary>& b) : boundary_{b} {}
    static std::shared_ptr<volume> ptr(const std::shared_ptr<const boundary>& b) {
      return std::make_shared<volume>(b);
    }
    const boundary& boundary() const {
      return *boundary_.get();
    }
    */

    //uniform_intersections get_uniform_intersectons...
    uniform_intersections get_uniform_intersections(size_t n_reflections) {
      double cs = boundary_->characteristic_size();
      return uniform_intersections(*boundary_, n_reflections, limits{cs*0.1,cs*100});
    }
    //template <class BoundaryT>
    //void insert(std::shared_ptr<volume> v_ptr) {
    void insert(const volume& v) {
      //n_volumes_outside_++;
      //v0.n_volumes_outside_ += n_volumes_outside_ + 1;

      //auto v_ptr = std::make_shared<volume>(v);
      inner_volumes_.emplace_back(v);
      //inner_volumes_.back()->outer_volume_ = this;
      //return *this;
    }
    friend std::ostream& operator<<(std::ostream &os, const volume& vol) {
      os << "(0,0) ";
      vol.write(os);
      return os;
    }
  private:
    void write(std::ostream& os=std::cout, size_t tree_depth=0) const {
      os << name_ << ", " << inner_volumes_.size() << ", "<< (*boundary_);
      os << '\n';
      for (size_t i=0; i<inner_volumes_.size(); ++i) {
	for (size_t j=0; j<=tree_depth; ++j)
	  os << "  ";
	os << "("<< tree_depth+1 <<","<< i << ") ";
	inner_volumes_.at(i).write(os,tree_depth+1);
      }
    }

    /*
    volume& set_observer(const pose& observer)
    {
      vector p_inner;
      double d_inner_min = std::numeric_limits<double>::max();
      for (size_t i=0; i < inner_volumes_.size(); ++i) {
	vector p = inner_volumes_.at(i)->boundary().intersection(observer);
	double d = norm(p_inner-observer.position()); 
	if (d < d_inner_min) {
	  d_inner_min = d;
	  p_inner = p;
	  closest_volume_ = inner_volumes_.at(i).get();
	}
      }
      closest_intersection_ = p_inner;
      vector p_boundary = boundary().intersection(observer);      
      if (norm(p_boundary-observer.position()) < d_inner_min) {
	closest_intersection_ = p_boundary;
	closest_volume_ = this;
      }
      return *this;
    }
    vector closest_intersection() const
    // closest boundary intersection point
    {
      return closest_intersection_;
    }
    const volume& closest_volume() const
    // closest to observer of this volume and volumes inside
    {
      return *closest_volume_;
    }
    */
  };

  class cube : public volume {
  public:
    cube(double side):
      volume(std::make_shared<cubical_boundary>(side),"cube") {
    }
  };
  class sphere : public volume {
  public:
    sphere(double side):
      volume(std::make_shared<spherical_boundary>(side),"sphere") {
    }
  };
  //std::shared_ptr<boundary> make_cube(double side)
  
  

  /*
  class shape {
  public:
    void write(std::ostream& str=std::cout) {
      str << name_;
    }
    std::shared_ptr<boundary> operator()(){return b_;}
  protected:
    std::string name_;
    std::shared_ptr<boundary> b_;
    
  };
  class cube_t : public shape {
  public:
    cube_t(double side) {
      name_ = "cube";
      double d = side/2;
      b_ = std::make_shared<boundary>();
      auto s = std::make_shared<surface::plane>();
      b_->add(s,{{0,0,d},rotation_to({0,0,1})});
      b_->add(s,{{0,0,-d},rotation_to({0,0,-1})});
      b_->add(s,{{0,d,0},rotation_to({0,1,0})});
      b_->add(s,{{0,-d,0},rotation_to({0,-1,0})});
      b_->add(s,{{d,0,0},rotation_to({1,0,0})});
      b_->add(s,{{-d,0,0},rotation_to({-1,0,0})});
    }
  };
  */
  //using cube = volume<cubical_boundary,double>;
  //using sphere = volume<spherical_boundary,double>;

}
#endif
